p4 + scale_colour_brewer()
p4 + scale_fill_hue(l=40)
p4
p4 + scale_colour_hue(l=40)
library("RColorBrewer")
p4$data$Phylum
levels(p4$data$Phylum)
?brewer.pal
my.cols <- brewer.pal(length(p4$data$Phylum), "Greens")
my.cols <- rainbow(length(p4$data$Phylum))
my.cols
my.cols <- rainbow(length(levels(p4$data$Phylum)))
my.cols
my.cols <- rainbow(length(levels(p4$data$Phylum)))
names(my.cols) <- levels(p4$data$Phylum)
my.cols
my.cols["samples"]
my.cols["samples"] <- "black"
p4 + scale_colour_manual(values=my.cols)
plot_ordination(GP1, GP.ca, type="split", color="Phylum", shape="human", label="SampleType")
p4 + scale_colour_manual(values=my.cols)
?update_legend
?qplot
p4 + scale_colour_manual(values=my.cols)
p4
plot_ordination(GP1, GP.ca, type="split", color="Phylum", shape="human", label="SampleType")#
p4 <- last_plot()#
# How to manually assign one (or more) colors#
my.cols <- rainbow(length(levels(p4$data$Phylum)))#
names(my.cols) <- levels(p4$data$Phylum)#
my.cols["samples"] <- "black"#
p4 + scale_colour_manual(values=my.cols)
(p4 <- plot_ordination(GP1, GP.ca, type="split", color="Phylum", shape="human", label="SampleType") )#
#
# Let's manually assign a new color-scheme, so that we can set "samples" to black#
# These are relatively general guidelines for manually assigning one (or more) colors#
my.cols <- rainbow(length(levels(p4$data$Phylum)))#
names(my.cols) <- levels(p4$data$Phylum)#
my.cols["samples"] <- "black"#
p5 <- p4 + scale_colour_manual(values=my.cols)#
(p5 <- p5 + opts(panel.background = theme_rect(colour="gray76", fill="gray76")) )
plot_ordination(GP1, GP.ca, type="split", color="Phylum", label="Species")
(p1 <- plot_ordination(GP1, GP.ca, type="taxa", color="Phylum"))
(p1 <- plot_ordination(GP1, GP.ca, type="taxa", color="Phylum")) + facet_wrap(~Phylum, nrow=3)
plot_ordination(GP1, GP.ca, type="taxa", color="Phylum") + facet_wrap(~Phylum, nrow=3)
p1b <- last_plot()
p1b + geom_density2d()
ggplot(p1$data, aes(x=CA1, y=CA2, color=Phylum)) + geom_density2d()
ggplot(p1$data, aes(x=CA1, y=CA2, color=Phylum)) + geom_density2d() + facet_wrap(~Phylum, nrow=3)
p1c <- last_plot()
?geom_density2d
ggplot(p1$data, aes(x=CA1, y=CA2, color=Phylum)) + geom_contour() + facet_wrap(~Phylum, nrow=3)
ggplot(p1$data, aes(x=CA1, y=CA2, color=Phylum)) + geom_hex() + facet_wrap(~Phylum, nrow=3)
ggplot(p1$data, aes(x=CA1, y=CA2, color=Phylum)) + stat_binhex() + facet_wrap(~Phylum, nrow=3)
install.packages(hexbin)
install.packages("hexbin")
ggplot(p1$data, aes(x=CA1, y=CA2, color=Phylum)) + geom_hex() + facet_wrap(~Phylum, nrow=3)
p1c
ggplot(p1$data, aes(x=CA1, y=CA2)) + stat_binhex() + facet_wrap(~Phylum, nrow=3)
nspecies(GP1)
plot_ordination(GP1, GP.ca, type="biplot", color="Phylum")
(p4 <- plot_ordination(GP1, GP.ca, type="split", color="Phylum", shape="human", label="SampleType") )
install.packages("neatmap")
install.packages("NeatMap")
library("NeatMap")
library("rgl")
library("NeatMap")
Build heatmap with R's built-in heatmap and default settings: #
#################################################################################
library("phyloseq")#
data("esophagus")#
heatmap(otuTable(esophagus))#
# The following example using t
are rotated:#
data("GlobalPatterns")#
gpac <- subset_species(GlobalPatterns, Phylum=="Crenarchaeota")#
heatmap(otuTable(gpac))
?NeatMap
?heatmap
?heatmap1
Try the same using NeatMap::heatmap1()#
#################################################################################
library("NeatMap")#
heatmap1(as(otuTable(esophagus), "matrix"))#
heatmap1(as(otuTable(gpac), "matrix"))#
make.heatmap1(as(otuTable(gpac), "matrix"), row.method="nMDS", column.method="nMDS",#
	row.labels=as(taxTab(gpac)[, "Genus"], "vector"), row.label.size=1)#
p <- last_plot()#
str(p)
?hclust
library("phyloseq")
test <- import_biom("~/Downloads/otu_table_summarized.biom")
test_file <- "~/Downloads/otu_table_summarized.biom"
BIOMfilename <- test_file
library("phyloseq"); library("RJSONIO")
Read the data#
	x <- fromJSON(BIOMfilename)#
	#########################################
	# OTU table:#
	#########################################
	# Check if sparse. Must parse differently than dense#
	if( x$matrix_type == "sparse" ){#
		otumat <- matrix(0, nrow=x$shape[1], ncol=x$shape[2])#
		dummy <- sapply(x$data, function(i){otumat[(i[1]+1), (i[2]+1)] <<- i[3]})#
	}#
	# parse the dense matrix instead.#
	if( x$matrix_type == "dense" ){#
		# each row will be complete data values, should use laply#
		# laply(x$data, vector, nrow=x$shape[1], ncol=x$shape[2])#
		otumat <- laply(x$data, function(i){i}, .parallel=parallel)#
	}#
	# Get row (OTU) and col (sample) names#
	rownames(otumat) <- sapply(x$rows, function(i){i$id})#
	colnames(otumat) <- sapply(x$columns, function(i){i$id})#
	otutab <- otuTable(otumat, TRUE)#
	#########################################
	# Taxonomy Table#
	#########################################
	# Need to check if taxonomy information is empty (minimal BIOM file)#
	if(  all( sapply(sapply(x$rows, function(i){i$metadata}), is.null) )  ){#
		taxtab <- NULL#
	} else {#
		if( is.null(taxaPrefix) ){#
			taxdf <- laply(x$rows, function(i){i$metadata$taxonomy}, .parallel=parallel)#
		} else if( taxaPrefix == "greengenes" ){#
			taxdf <- laply(x$rows, function(i){parseGreenGenesPrefix(i$metadata$taxonomy)}, .parallel=parallel)#
		} else {#
			taxdf <- laply(x$rows, function(i){i$metadata$taxonomy}, .parallel=parallel)#
		}#
		# Now convert to matrix, name the rows as "id" (the taxa name), coerce to taxonomyTable#
		taxtab           <- as(taxdf, "matrix")#
		rownames(taxtab) <- sapply(x$rows, function(i){i$id})#
		taxtab <- taxTab(taxtab)	#
	}#
	#########################################
	# Sample Data ("columns" in QIIME/BIOM)#
	#########################################
	# If there is no metadata (all NULL), then set samdata <- NULL#
	if(  all( sapply(sapply(x$columns, function(i){i$metadata}), is.null) )  ){#
		samdata <- NULL#
	} else {#
		samdata           <- ldply(x$columns, function(i){i$metadata}, .parallel=parallel)#
		rownames(samdata) <- sapply(x$columns, function(i){i$id})#
		samdata <- sampleData(samdata)#
	}#
	#########################################
	# Put together into a phyloseq object
library("phyloseq"); library("RJSONIO"); library("plyr")
Read the data#
	x <- fromJSON(BIOMfilename)#
	#########################################
	# OTU table:#
	#########################################
	# Check if sparse. Must parse differently than dense#
	if( x$matrix_type == "sparse" ){#
		otumat <- matrix(0, nrow=x$shape[1], ncol=x$shape[2])#
		dummy <- sapply(x$data, function(i){otumat[(i[1]+1), (i[2]+1)] <<- i[3]})#
	}#
	# parse the dense matrix instead.#
	if( x$matrix_type == "dense" ){#
		# each row will be complete data values, should use laply#
		# laply(x$data, vector, nrow=x$shape[1], ncol=x$shape[2])#
		otumat <- laply(x$data, function(i){i}, .parallel=parallel)#
	}#
	# Get row (OTU) and col (sample) names#
	rownames(otumat) <- sapply(x$rows, function(i){i$id})#
	colnames(otumat) <- sapply(x$columns, function(i){i$id})#
	otutab <- otuTable(otumat, TRUE)#
	#########################################
	# Taxonomy Table#
	#########################################
	# Need to check if taxonomy information is empty (minimal BIOM file)#
	if(  all( sapply(sapply(x$rows, function(i){i$metadata}), is.null) )  ){#
		taxtab <- NULL#
	} else {#
		if( is.null(taxaPrefix) ){#
			taxdf <- laply(x$rows, function(i){i$metadata$taxonomy}, .parallel=parallel)#
		} else if( taxaPrefix == "greengenes" ){#
			taxdf <- laply(x$rows, function(i){parseGreenGenesPrefix(i$metadata$taxonomy)}, .parallel=parallel)#
		} else {#
			taxdf <- laply(x$rows, function(i){i$metadata$taxonomy}, .parallel=parallel)#
		}#
		# Now convert to matrix, name the rows as "id" (the taxa name), coerce to taxonomyTable#
		taxtab           <- as(taxdf, "matrix")#
		rownames(taxtab) <- sapply(x$rows, function(i){i$id})#
		taxtab <- taxTab(taxtab)	#
	}#
	#########################################
	# Sample Data ("columns" in QIIME/BIOM)#
	#########################################
	# If there is no metadata (all NULL), then set samdata <- NULL#
	if(  all( sapply(sapply(x$columns, function(i){i$metadata}), is.null) )  ){#
		samdata <- NULL#
	} else {#
		samdata           <- ldply(x$columns, function(i){i$metadata}, .parallel=parallel)#
		rownames(samdata) <- sapply(x$columns, function(i){i$id})#
		samdata <- sampleData(samdata)#
	}#
	#########################################
	# Put together into a phyloseq object
taxaPrefix=NULL; parallel=FALSE; version=0.9
Read the data#
	x <- fromJSON(BIOMfilename)#
	#########################################
	# OTU table:#
	#########################################
	# Check if sparse. Must parse differently than dense#
	if( x$matrix_type == "sparse" ){#
		otumat <- matrix(0, nrow=x$shape[1], ncol=x$shape[2])#
		dummy <- sapply(x$data, function(i){otumat[(i[1]+1), (i[2]+1)] <<- i[3]})#
	}#
	# parse the dense matrix instead.#
	if( x$matrix_type == "dense" ){#
		# each row will be complete data values, should use laply#
		# laply(x$data, vector, nrow=x$shape[1], ncol=x$shape[2])#
		otumat <- laply(x$data, function(i){i}, .parallel=parallel)#
	}#
	# Get row (OTU) and col (sample) names#
	rownames(otumat) <- sapply(x$rows, function(i){i$id})#
	colnames(otumat) <- sapply(x$columns, function(i){i$id})#
	otutab <- otuTable(otumat, TRUE)#
	#########################################
	# Taxonomy Table#
	#########################################
	# Need to check if taxonomy information is empty (minimal BIOM file)#
	if(  all( sapply(sapply(x$rows, function(i){i$metadata}), is.null) )  ){#
		taxtab <- NULL#
	} else {#
		if( is.null(taxaPrefix) ){#
			taxdf <- laply(x$rows, function(i){i$metadata$taxonomy}, .parallel=parallel)#
		} else if( taxaPrefix == "greengenes" ){#
			taxdf <- laply(x$rows, function(i){parseGreenGenesPrefix(i$metadata$taxonomy)}, .parallel=parallel)#
		} else {#
			taxdf <- laply(x$rows, function(i){i$metadata$taxonomy}, .parallel=parallel)#
		}#
		# Now convert to matrix, name the rows as "id" (the taxa name), coerce to taxonomyTable#
		taxtab           <- as(taxdf, "matrix")#
		rownames(taxtab) <- sapply(x$rows, function(i){i$id})#
		taxtab <- taxTab(taxtab)	#
	}#
	#########################################
	# Sample Data ("columns" in QIIME/BIOM)#
	#########################################
	# If there is no metadata (all NULL), then set samdata <- NULL#
	if(  all( sapply(sapply(x$columns, function(i){i$metadata}), is.null) )  ){#
		samdata <- NULL#
	} else {#
		samdata           <- ldply(x$columns, function(i){i$metadata}, .parallel=parallel)#
		rownames(samdata) <- sapply(x$columns, function(i){i$id})#
		samdata <- sampleData(samdata)#
	}#
	#########################################
	# Put together into a phyloseq object
is.null(taxaPrefix)
taxdf <- laply(x$rows, function(i){i$metadata$taxonomy}, .parallel=parallel)
head(x$rows)
?laply
? rbind.fill.matrix
lapply(head(x$rows), function(i){i$metadata$taxonomy})
rbind.fill(lapply(head(x$rows), function(i){i$metadata$taxonomy}))
laply(lapply(head(x$rows), function(i){i$metadata$taxonomy}))
taxdf <- laply(x$rows, function(i){i$metadata$taxonomy}, .parallel=parallel, .drop=FALSE)
max(sapply(head(x$rows), function(i){length(i$metadata$taxonomy)}))
ncols
ncols <- max(sapply(head(x$rows), function(i){length(i$metadata$taxonomy)}))
length(x$rows)
nrow(otutab)
taxdf <- matrix(NA, nrow=length(x$rows), ncol=ncols)
taxdf
test <- ldply(x$rows, function(i){i$metadata$taxonomy}, .parallel=parallel)
mx
x[[1]]
x[[2]]
x$rows[[1]]
i=1
i
mx[[i]]$metadata$taxonomy
x[[i]]$metadata$taxonomy
x$rows[[i]]$metadata$taxonomy
on each iteration, assign to the matrix#
			test <- lapply(1:length(x$rows), function(i, mx){#
				taxdf[length(mx[[i]]$metadata$taxonomy), ] <<- mx[[i]]$metadata$taxonomy#
			}, mx=x$rows)#
			# test <- ldply(x
library("phyloseq")
?plot_heatmap
plot_heatmap(gpac, "MDS", "unifrac")
Subset the dataset to something manageable that can be reasonably#
# represented in one plot. In this example, the Crenarchaeota phylum.#
gpac <- subset_species(GlobalPatterns, Phylum=="Crenarchaeota")#
# Here is how you might create a heatmap using base-R graphics#
# and the more common (but problematic) hierarchical clustering#
# organization.#
# ```R#
heatmap(otuTable(gpac))#
# Now let's see how our `plot_heatmap` function works with all default settings.#
# ```R#
plot_heatmap(gpac)
heatmap(otuTable(gpac))
ptex_dir <- "~/Dropbox/R/plot_heatmap_wiki/"
Now let's see how our `plot_heatmap` function works with all default settings.#
# ```R#
plot_heatmap(gpac)#
# ```#
p1 <- last_plot()#
# ######################### Save the graphic to file.#
width  <- 7#
height <- 10 #
ggsave(#
	filename = paste(ptex_dir, "plot_heatmap", 1, ".png", sep=""),#
	plot = p1, width=width, height=height#
)#
# exampl
library("ggplot2")
Save the graphic to file.#
width  <- 7#
height <- 10 #
ggsave(#
	filename = paste(ptex_dir, "plot_heatmap", 1, ".png", sep=""),#
	plot = p1, width=width, height=height#
)#
# example rel
Now let's see how our `plot_heatmap` function works with all default settings.#
# ```R#
plot_heatmap(gpac)#
# ```#
p1 <- last_plot()#
# ######################### Save the graphic to file.#
width  <- 7#
height <- 10 #
ggsave(#
	filename = paste(ptex_dir, "plot_heatmap", 1, ".png", sep=""),#
	plot = p1, width=width, height=height#
)#
# example relabel
example relabelling based on a sample variable and taxonomic rank.#
# ```R#
plot_heatmap(gpac, "NMDS", "bray", "SampleType", "Family")#
# ```#
p2 <- last_plot()#
ggsave(#
	filename = paste(ptex_dir, "plot_heatmap", 2, ".png", sep=""),#
	plot = p2, width=width, height=height#
)#
# ### Now repeat the plot, but change the color scheme.#
# #
# This may be worthwhile, depending on the graphics device or paper#
# on which you want to discplay the heatmap.#
# ```R#
plot_heatmap(gpac, "NMDS", "bray", "SampleType", "Family", low="#000033", high="#CCFF66")#
# ```#
p3 <- last_plot()#
ggsave(#
	filename = paste(ptex_dir, "plot_heatmap", 3, ".png", sep=""),#
	plot = p3, width=width, height=height#
)
plot_heatmap(gpac, "NMDS", "bray", "SampleType", "Family")
plot_heatmap(gpac, "NMDS", "bray", "SampleType", "Family", low="#000033", high="#CCFF66")
plot_heatmap(gpac, "NMDS", "bray", "SampleType", "Family", low="#000033", high="#FF3300")
plot_heatmap(gpac, "NMDS", "bray", "SampleType", "Family", low="#000033", high="#66CCFF")
plot_heatmap(gpac, "NMDS", "bray", "SampleType", "Family", low="#66CCFF", high="#000033", na.value="white")
plot_heatmap(gpac, "NMDS", "bray", "SampleType", "Family", low="#FFFFCC", high="#000033", na.value="white")
plot_heatmap(gpac, "NMDS", "bray", "SampleType", "Family", low="#66CCFF", high="#000033", na.value="white")
plot_heatmap(gpac, "NMDS", "bray", "SampleType", "Family", low="#000033", high="#66CCFF")
colors()
?colors
palette()
library("devtools")
install_github("phyloseq", "joey711")
library("phyloseq")
?plot_heatmap
library("phyloseq")
?soilrep
data(soilrep)
sampleData(soilrep)
soilrep
sum(otuTable(soilrep))
max(otuTable(soilrep))
library(veganm)
library(vegan)
?cca
library(phyloseq)
?DPCoA
multidimensional scaling
?MDS
?cmdscale
?metaMDS
library("phyloseq")
?phyloseq
data(enterotype)
ig <- make_network(enterotype, type="species", max.dist=0.3)
plot_network(ig, enterotype, type="species", color="Genus", line_weight=0.2, label=NULL)
p <- last_plot()
library('ggplot')
library('ggplot2')
p <- last_plot()
p
ig <- make_network(enterotype, type="species", max.dist=0.5)
plot_network(ig, enterotype, type="species", color="Genus", line_weight=0.2, label=NULL)
ig <- make_network(enterotype, type="species", max.dist=0.8)
p <- plot_network(ig, enterotype, type="species", line_weight=0.2, label=NULL)
print(p)
library("phyloseq")
data(GlobalPatterns)
topsp <- sort(speciesSums(GlobalPatterns), TRUE)[1:200]
GP    <- prune_species(names(topsp), GlobalPatterns)
GP.wuf.mds <- ordinate(GP, "MDS", distance="unifrac", weighted=TRUE)
scores(GP.wuf.mds)
class(GP.wuf.mds)
phyloseq:::scores.pcoa(GP.wuf.mds)
x      <-  phyloseq:::scores.pcoa(GP.wuf.mds)[, 1:4]
gskmn <- clusGap(x, FUN = kmeans, nstart = 20, K.max = 8, B = 100)
library("cluster")
gskmn <- clusGap(x, FUN = kmeans, nstart = 20, K.max = 8, B = 100)
gskmn
library("devtools")
install_github("phyloseq", "joey711")
library("phyloseq")
data(soilrep)
sampleData(soilrep)
estimate_richness(soilrep)
sampleSums(soilrep)
nspecies(soilrep)
rm(list=ls())
library("phyloseq")
data("soilrep")
library(phyloseq)
data(soilrep)
read.table("http://cloud.github.com/downloads/joey711/phyloseq/soilrep.txt")
read.table("http://cloud.github.com/downloads/joey711/phyloseq/soilrep.txt", TRUE)
table.addendum <- read.table("http://cloud.github.com/downloads/joey711/phyloseq/soilrep.txt", TRUE)
srdata.addendum <- read.table("http://cloud.github.com/downloads/joey711/phyloseq/soilrep.txt", TRUE)
srdata.addendum$Tag
as(srdata.addendum$Tag, "character")
rownames(srdata.addendum) <- as(srdata.addendum$Tag, "character")
srdata.addendum
sample.names(soilrep)
paste("a_", as(srdata.addendum$Tag, "character"), ,sep="")
srdata.addendum$Tag
paste("a_", as(srdata.addendum$Tag, "character"), sep="")
soilrep.sample
srdata.addendum
Sample
Sample <- srdata.addendum$Sample
Sample
Sample <- as(srdata.addendum$Sample, "character")
Sample
Sample <- as(srdata.addendum$Sample, "character")
names(Sample) <- paste("a_", as(srdata.addendum$Tag, "character"), sep="")
Sample
sampleData(soilrep)
sample.names(soilrep)
Sample
Sample[sample.names(soilrep)]
Parse soilrep sample-replicate labels, and add to soilrep dataset#
rm(list=ls())#
library(phyloseq)#
data(soilrep)#
# Read the table.#
srdata.addendum <- read.table("http://cloud.github.com/downloads/joey711/phyloseq/soilrep.txt", TRUE)#
print(srdata.addendum)#
# Note that the sample.names for soilrep don't match the sample.names in the table#
sample.names(soilrep)#
# Need to add "a_" in front of all the names in the table.#
Sample <- as(srdata.addendum$Sample, "character")#
names(Sample) <- paste("a_", as(srdata.addendum$Tag, "character"), sep="")#
# Reorder#
Sample <- Sample[sample.names(soilrep)]#
# Finally, add the factor to the soilrep dataset.#
sampleData(soilrep)$Sample <- factor(Sample)
sampleData(soilrep)
Parse soilrep sample-replicate labels, and add to soilrep dataset#
rm(list=ls())#
library(phyloseq)#
data(soilrep)#
# Read the table.#
srdata.addendum <- read.table("http://cloud.github.com/downloads/joey711/phyloseq/soilrep.txt", TRUE)#
print(srdata.addendum)#
# Note that the sample.names for soilrep don't match the sample.names in the table#
sample.names(soilrep)#
# Need to add "a_" in front of all the names in the table.#
Sample <- as(srdata.addendum$Sample, "character")#
names(Sample) <- paste("a_", as(srdata.addendum$Tag, "character"), sep="")#
# Reorder#
Sample <- Sample[sample.names(soilrep)]#
# Finally, add the factor to the soilrep dataset.#
sampleData(soilrep)$Sample <- factor(Sample)#
#
# Now that is done, can save a new compressed version of #
# the soilrep example dataset with the sample-replicate lable included.#
save(soilrep, file="~/github/phyloseq/data/soilrep2.RData")
?save
save(soilrep, file="~/github/phyloseq/data/soilrep2.RData", compress=TRUE)
head(species.names(soilrep))
Parse soilrep sample-replicate labels, and add to soilrep dataset#
rm(list=ls())#
library(phyloseq)#
data(soilrep)#
# Read the table.#
srdata.addendum <- read.table("http://cloud.github.com/downloads/joey711/phyloseq/soilrep.txt", TRUE)#
print(srdata.addendum)#
# Note that the sample.names for soilrep don't match the sample.names in the table#
sample.names(soilrep)#
# Need to add "a_" in front of all the names in the table.#
Sample <- as(srdata.addendum$Sample, "character")#
names(Sample) <- paste("a_", as(srdata.addendum$Tag, "character"), sep="")#
# Reorder#
Sample <- Sample[sample.names(soilrep)]#
# Finally, add the factor to the soilrep dataset.#
sampleData(soilrep)$Sample <- factor(Sample)#
#
# Now that is done, can save a new compressed version of #
# the soilrep example dataset with the sample-replicate lable included.#
save(soilrep, file="~/github/phyloseq/data/soilrep.RData")
?install.packages
source("http://bioconductor.org/biocLite.R")
?biocLite
library("testthat")
?test_package
?auto_test
library("RJSONIO"); library("plyr"); library("Matrix")#
parallel <- FALSE#
#
if( getwd() != "~/github/biom-format/R-code/RBIOM/R"){#
	setwd("~/github/biom-format/R-code/RBIOM/R")#
}#
#
min_dense_file   <- "../../../examples/min_dense_otu_table.biom"#
min_sparse_file  <- "../../../examples/min_sparse_otu_table.biom"#
rich_dense_file  <- "../../../examples/rich_dense_otu_table.biom"#
rich_sparse_file <- "../../../examples/rich_sparse_otu_table.biom"#
#
# Test read_biom#
x1 <- read_biom(min_dense_file)#
x2 <- read_biom(min_sparse_file)#
x3 <- read_biom(rich_dense_file)#
x4 <- read_biom(rich_sparse_file)#
#
# Test that both mins are equal, and that both riches are equal#
if( !identical(x1, x2) ){#
	all.equal(x1, x2)#
	all.equal(abundance(x1), abundance(x2))#
	abundance(x1) - abundance(x2)#
}#
#
if( !identical(x3, x4) ){#
	all.equal(x3, x4)#
	all.equal(abundance(x3), abundance(x4))#
	abundance(x3) - abundance(x4)	#
}#
#
identical(abundance(x1), abundance(x3))#
identical(abundance(x2), abundance(x4))
library("RJSONIO"); library("plyr"); library("Matrix"); library("RBIOM")
RBIOM biom import tests#
##
##
library("RJSONIO"); library("plyr"); library("Matrix"); library("RBIOM")#
parallel <- FALSE#
#
if( getwd() != "~/github/biom-format/R-code/RBIOM/R"){#
	setwd("~/github/biom-format/R-code/RBIOM/R")#
}#
#
min_dense_file   <- "../../../examples/min_dense_otu_table.biom"#
min_sparse_file  <- "../../../examples/min_sparse_otu_table.biom"#
rich_dense_file  <- "../../../examples/rich_dense_otu_table.biom"#
rich_sparse_file <- "../../../examples/rich_sparse_otu_table.biom"#
#
# Test read_biom#
x1 <- read_biom(min_dense_file)#
x2 <- read_biom(min_sparse_file)#
x3 <- read_biom(rich_dense_file)#
x4 <- read_biom(rich_sparse_file)#
#
# Test that both mins are equal, and that both riches are equal#
if( !identical(x1, x2) ){#
	all.equal(x1, x2)#
	all.equal(abundance(x1), abundance(x2))#
	abundance(x1) - abundance(x2)#
}#
#
if( !identical(x3, x4) ){#
	all.equal(x3, x4)#
	all.equal(abundance(x3), abundance(x4))#
	abundance(x3) - abundance(x4)	#
}#
#
identical(abundance(x1), abundance(x3))#
identical(abundance(x2), abundance(x4))
library("RBIOM"); library("testthat")
expect_that(x2, is_equivalent_to(x4))
expect_that(x2, is_equivalent_to(x3))
identical(x2, x3)
class("x2")
class(x2)
expect_that(x2, is_equivalent_to(x4))
expect_that(x2, equals(x4))
expect_that(x2, is_a("BIOM"))
expect_that(x2, is_equivalent_to(x1))
expect_that(x2, is_identical_to(x1))
expect_that(x2, is_identical_to(x4))
expect_that(abundance(x2), is_identical_to(abundance(x4)))
expect_that(abundance(x2), is_identical_to(abundance(x1)))
expect_that(abundance(x1), is_identical_to(abundance(x3)))
class(abundance(x2))
abundance(x2)
class(abundance(x1))
x1
class(abundance(x3))
x3
class(NULL)
class(taxonomy(x1))
taxonomy(x1)
taxonomy(x1, FALSE)
class(taxonomy(x1, FALSE))
expect_that(taxonomy(x1, FALSE), is_a("NULL"))
expect_that(sampleData(x1, FALSE), is_a("NULL"))
