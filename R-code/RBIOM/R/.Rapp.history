library("plyr")
library("RJSONIO"); library("plyr")
test_file <- "~/Downloads/otu_table_summarized.biom"
cd
?dir
dir
dir()
?dir
getwd()
setwd("~/github/biom-format/R-code/RBIOM/R")
getwd()
library("RJSONIO"); library("plyr")#
#
if( getwd() != "~/github/biom-format/R-code/RBIOM/R"){#
	setwd("~/github/biom-format/R-code/RBIOM/R")#
}#
#
min_dense_file   <- "../../../examples/min_dense_otu_table.biom"#
min_sparse_file  <- "../../../examples/min_sparse_otu_table.biom"#
rich_dense_file  <- "../../../examples/rich_dense_otu_table.biom"#
rich_sparse_file <- "../../../examples/rich_sparse_otu_table.biom"#
# Read the data#
x <- fromJSON(rich_sparse_file)
x
parallel=FALSE
x$rows
x$rows[[1]]
taxdf <- ldply(x$rows, function(i){i$metadata$taxonomy}, .parallel=parallel)
taxdf
x
clip out the first 3 characters, and#
# name according to the taxonomic rank#
#' @keywords internal#
parseGreenGenesPrefix <- function(char.vec){#
	# Define the meaning of each prefix according to GreenGenes (and RDP?) taxonomy#
	Tranks <- c(k="Kingdom", p="Phylum", c="Class", o="Order", f="Family", g="Genus", s="Species")#
	taxvec        <- substr(char.vec, 4, 1000)#
	names(taxvec) <- Tranks[substr(char.vec, 1, 1)]#
	# Make sure order is same as Tranks#
	taxvec <- taxvec[Tranks]; names(taxvec) <- Tranks#
	return(taxvec)#
}
i
i=1
i$metadata$taxonomy
i=names(x)[1]
i
names(x)
i=names(x$metadata)[1]
i
i=1
x$rows
i=x$rows[[1]]
i
taxdf <- ldply(x$rows, function(i){parseGreenGenesPrefix(x$rows[[i]]$metadata$taxonomy)}, .parallel=parallel)
i$metadata$taxonomy
taxdf <- ldply(x$rows, function(i){parseGreenGenesPrefix(i$metadata$taxonomy)}, .parallel=parallel)
taxdf
x
taxdf
rownames(taxdf) <- sapply(x$rows, function(i){i$id})
taxdf
x <- fromJSON(rich_dense_file)
i=x$rows[[1]]
taxdf <- ldply(x$rows, function(i){i$metadata$taxonomy}, .parallel=parallel)
taxdf
taxdf <- ldply(x$rows, function(i){parseGreenGenesPrefix(i$metadata$taxonomy)}, .parallel=parallel)
taxdf
library("RJSONIO"); library("plyr"); library("Matrix")
x <- fromJSON(rich_sparse_file)
Matrix(0, nrow=x$shape[1], ncol=x$shape[2])
otumat <- Matrix(0, nrow=x$shape[1], ncol=x$shape[2])#
		dummy  <- sapply(x$data, function(i){otumat[(i[1]+1), (i[2]+1)] <<- i[3]})
dummy
x$data
otumat <- Matrix(0, nrow=x$shape[1], ncol=x$shape[2])
for( i in x$data ){otumat[(i[1]+1), (i[2]+1)] <- i[3]}
otumat
dummy
otumat ==
askjfla
clip out the first 3 characters, and#
# name according to the taxonomic rank#
#' @keywords internal#
parseGreenGenesPrefix <- function(char.vec){#
	# Define the meaning of each prefix according to GreenGenes (and RDP?) taxonomy#
	Tranks <- c(k="Kingdom", p="Phylum", c="Class", o="Order", f="Family", g="Genus", s="Species")#
	taxvec        <- substr(char.vec, 4, 1000)#
	names(taxvec) <- Tranks[substr(char.vec, 1, 1)]#
	# Make sure order is same as Tranks#
	taxvec <- taxvec[Tranks]; names(taxvec) <- Tranks#
	return(taxvec)#
}#
#################################################################################
#################################################################################
#' Read a BIOM file#
#'#
#' New versions of QIIME produce a more-comprehensive and formally-defined#
#' JSON file format. From the QIIME website:#
#'#
#' ``The biom file format (canonically pronounced `biome') is designed to be a #
#' general-use format for representing counts of observations in one or#
#' more biological samples.''#
#' #
#' \url{http://biom-format.org/} #
#'#
#' @usage read_biom(BIOMfilename, taxaPrefix=NULL, version=0.9)#
#'#
#' @param BIOMfilename (Required). A character string indicating the #
#'  file location of the BIOM formatted file. This is a JSON formatted file,#
#'  specific to biological datasets, as described in #
#' #
#'  \url{http://www.qiime.org/svn_documentation/documentation/biom_format.html}#
#' #
#' @param taxaPrefix (Optional). Character string. What category of prefix precedes#
#'  the taxonomic label at each taxonomic rank. Currently only ``greengenes'' is#
#'  a supported option, and implies that the first letter indicates the #
#'  taxonomic rank, followed by two underscores and then the actual taxonomic#
#'  assignment at that rank. The default value is \code{NULL}, meaning that#
#'  no prefix or rank identifier will be interpreted. #
#' #
#' @param version (Optional). Numeric. The expected version number of the file.#
#'  As the BIOM format evolves, version-specific importers will be available#
#'  by adjusting the version value. Default is \code{1.0}. Not implemented.#
#'  Has no effect (yet).#
#'#
#' @return An instance of the \code{biom-class}.#
#'#
#' @references \url{http://www.qiime.org/svn_documentation/documentation/biom_format.html}#
#'#
#' @importFrom RJSONIO fromJSON#
#' @importFrom plyr ldply#
#' @importFrom plyr laply#
#' @export#
#' @examples#
#'  # # # import with default parameters, specify a file#
#'  # read_biom(myBIOMfile)#
read_biom <- function(BIOMfilename, taxaPrefix=NULL, version=1.0){#
	# Read the data#
	x <- fromJSON(BIOMfilename)#
	#########################################
	# OTU table:#
	#########################################
	# Check if sparse. Must parse differently than dense#
	if( x$matrix_type == "sparse" ){#
		otumat <- Matrix(0, nrow=x$shape[1], ncol=x$shape[2])#
		# Loop through each sparse line and assign to relevant position in otumat.#
		for( i in x$data ){#
			otumat[(i[1]+1), (i[2]+1)] <- i[3]#
		}#
	} else if( x$matrix_type == "dense" ){ #
		# parse the dense matrix instead using plyr's laply#
		otumat <- laply(x$data, function(i){i})#
	}#
	# Get row (OTU) and col (sample) names#
	rownames(otumat) <- sapply(x$rows, function(i){i$id})#
	colnames(otumat) <- sapply(x$columns, function(i){i$id})#
	# Instantiates a "Matrix" class object, usually sparse.#
	ab.mat <- Matrix(otumat)#
	#########################################
	# Taxonomy Table#
	#########################################
	# Need to check if taxonomy information is empty (minimal BIOM file)#
	if(  all( sapply(sapply(x$rows, function(i){i$metadata}), is.null) )  ){#
		taxdf <- NULL#
	} else {#
		# If GreenGenes, trim the prefix and use to name ultimately variable/column#
		if( sum(taxaPrefix %in% "greengenes") > 0 ){#
			taxdf <- ldply(x$rows, function(i){parseGreenGenesPrefix(i$metadata$taxonomy)}, .parallel=parallel)#
		} else {#
			taxdf <- ldply(x$rows, function(i){i$metadata$taxonomy}, .parallel=parallel)#
		}#
		# Add rownames to taxonomy data.frame.#
		rownames(taxdf) <- sapply(x$rows, function(i){i$id})#
	}#
	#########################################
	# Sample Data ("columns" in QIIME/BIOM)#
	#########################################
	# If there is no metadata (all NULL), then set samdata <- NULL#
	if(  all( sapply(sapply(x$columns, function(i){i$metadata}), is.null) )  ){#
		samdata <- NULL#
	} else {#
		samdata <- ldply(x$columns, function(i){#
			if( class(i$metadata) == "list"){#
				return(i$metadata[[1]])#
			} else {#
				return(i$metadata)				#
			}#
		}, .parallel=parallel)#
		rownames(samdata) <- sapply(x$columns, function(i){i$id})#
	}#
	#########################################
	# Put together into a list. #
	# Should eventually be a BIOM object (special class)#
	#########################################
	# Add header (not empty list by default, read file.)#
	# Add tree read/test if that is implemented.#
	return( BIOM(ab.mat, header=list(), taxonomy=taxdf, sampleData=samdata, tree=NULL) )#
#
}
' An S4 copy of the main phylogenetic tree class from the ape package.#
#'#
#' See the \code{\link[ape]{ape}} package for details about this type of#
#' representation of a phylogenetic tree. It is used throught ape.#
#'#
#' @seealso \code{\link[ape]{phylo}}, \code{\link{setOldClass}}#
#'#
#' @name phylo-class#
#' @rdname phylo-class#
#' @exportClass phylo#
setOldClass("phylo")#
#################################################################################
# Use setClassUnion to define the unholy NULL-data union as a virtual class.#
# This is a way of dealing with the expected scenarios in which one or more of#
# the component data classes is not available, in which case NULL will be used#
# instead.#
#################################################################################
#' @keywords internal#
setClassUnion("dataFrameOrNull", c("data.frame", "NULL"))#
#' @keywords internal#
setClassUnion("matrixOrNULL", c("matrix", "NULL"))#
#' @keywords internal#
setClassUnion("phyloOrNULL", c("phylo", "NULL"))#
#################################################################################
# Eventually, class definitions should go here. Most expected is a class#
# definition for the "BIOM" class that represents generally the BIOM format#
# structure within R.#
#################################################################################
#' A native R-representation of the BIOM format.#
#'#
#' For documentation of the format see \url{http://biom-format.org/}. #
#' #
#' slots:#
#' \describe{#
#'    \item{otuTable}{a single object of class otuTable.}#
#'    \item{samData}{ a single object of class sampleData.}#
#'    \item{taxTab}{ a single object of class taxonomyTable.}#
#'    \item{tre}{ a single object of class phylo, from the package ape}#
#' }#
#'#
#' @seealso#
#' The constructor, \code{\link{BIOM}}#
#' #
#' The accessors, \code{\link{header}}, \code{\link{abundance}},#
#'  \code{\link{taxonomy}}, \code{\link{sampleData}}, \code{\link{tree}}.#
#' #
#' @name BIOM-class#
#' @rdname BIOM-class#
#' @exportClass BIOM#
setClass("BIOM",#
	representation(#
	header     = "list",#
	abundance  = "Matrix",#
	taxonomy   = "matrixOrNULL",#
	sampleData = "dataFrameOrNull",#
	tree       = "phyloOrNULL")#
)
clip out the first 3 characters, and#
# name according to the taxonomic rank#
#' @keywords internal#
parseGreenGenesPrefix <- function(char.vec){#
	# Define the meaning of each prefix according to GreenGenes (and RDP?) taxonomy#
	Tranks <- c(k="Kingdom", p="Phylum", c="Class", o="Order", f="Family", g="Genus", s="Species")#
	taxvec        <- substr(char.vec, 4, 1000)#
	names(taxvec) <- Tranks[substr(char.vec, 1, 1)]#
	# Make sure order is same as Tranks#
	taxvec <- taxvec[Tranks]; names(taxvec) <- Tranks#
	return(taxvec)#
}#
#################################################################################
#################################################################################
#' Read a BIOM file#
#'#
#' New versions of QIIME produce a more-comprehensive and formally-defined#
#' JSON file format. From the QIIME website:#
#'#
#' ``The biom file format (canonically pronounced `biome') is designed to be a #
#' general-use format for representing counts of observations in one or#
#' more biological samples.''#
#' #
#' \url{http://biom-format.org/} #
#'#
#' @usage read_biom(BIOMfilename, taxaPrefix=NULL, version=0.9)#
#'#
#' @param BIOMfilename (Required). A character string indicating the #
#'  file location of the BIOM formatted file. This is a JSON formatted file,#
#'  specific to biological datasets, as described in #
#' #
#'  \url{http://www.qiime.org/svn_documentation/documentation/biom_format.html}#
#' #
#' @param taxaPrefix (Optional). Character string. What category of prefix precedes#
#'  the taxonomic label at each taxonomic rank. Currently only ``greengenes'' is#
#'  a supported option, and implies that the first letter indicates the #
#'  taxonomic rank, followed by two underscores and then the actual taxonomic#
#'  assignment at that rank. The default value is \code{NULL}, meaning that#
#'  no prefix or rank identifier will be interpreted. #
#' #
#' @param version (Optional). Numeric. The expected version number of the file.#
#'  As the BIOM format evolves, version-specific importers will be available#
#'  by adjusting the version value. Default is \code{1.0}. Not implemented.#
#'  Has no effect (yet).#
#'#
#' @return An instance of the \code{biom-class}.#
#'#
#' @references \url{http://www.qiime.org/svn_documentation/documentation/biom_format.html}#
#'#
#' @importFrom RJSONIO fromJSON#
#' @importFrom plyr ldply#
#' @importFrom plyr laply#
#' @export#
#' @examples#
#'  # # # import with default parameters, specify a file#
#'  # read_biom(myBIOMfile)#
read_biom <- function(BIOMfilename, taxaPrefix=NULL, version=1.0){#
	# Read the data#
	x <- fromJSON(BIOMfilename)#
	#########################################
	# OTU table:#
	#########################################
	# Check if sparse. Must parse differently than dense#
	if( x$matrix_type == "sparse" ){#
		otumat <- Matrix(0, nrow=x$shape[1], ncol=x$shape[2])#
		# Loop through each sparse line and assign to relevant position in otumat.#
		for( i in x$data ){#
			otumat[(i[1]+1), (i[2]+1)] <- i[3]#
		}#
	} else if( x$matrix_type == "dense" ){ #
		# parse the dense matrix instead using plyr's laply#
		otumat <- laply(x$data, function(i){i})#
	}#
	# Get row (OTU) and col (sample) names#
	rownames(otumat) <- sapply(x$rows, function(i){i$id})#
	colnames(otumat) <- sapply(x$columns, function(i){i$id})#
	# Instantiates a "Matrix" class object, usually sparse.#
	ab.mat <- Matrix(otumat)#
	#########################################
	# Taxonomy Table#
	#########################################
	# Need to check if taxonomy information is empty (minimal BIOM file)#
	if(  all( sapply(sapply(x$rows, function(i){i$metadata}), is.null) )  ){#
		taxdf <- NULL#
	} else {#
		# If GreenGenes, trim the prefix and use to name ultimately variable/column#
		if( sum(taxaPrefix %in% "greengenes") > 0 ){#
			taxdf <- ldply(x$rows, function(i){parseGreenGenesPrefix(i$metadata$taxonomy)}, .parallel=parallel)#
		} else {#
			taxdf <- ldply(x$rows, function(i){i$metadata$taxonomy}, .parallel=parallel)#
		}#
		# Add rownames to taxonomy data.frame.#
		rownames(taxdf) <- sapply(x$rows, function(i){i$id})#
	}#
	#########################################
	# Sample Data ("columns" in QIIME/BIOM)#
	#########################################
	# If there is no metadata (all NULL), then set samdata <- NULL#
	if(  all( sapply(sapply(x$columns, function(i){i$metadata}), is.null) )  ){#
		samdata <- NULL#
	} else {#
		samdata <- ldply(x$columns, function(i){#
			if( class(i$metadata) == "list"){#
				return(i$metadata[[1]])#
			} else {#
				return(i$metadata)				#
			}#
		}, .parallel=parallel)#
		rownames(samdata) <- sapply(x$columns, function(i){i$id})#
	}#
	#########################################
	# Put together into a list. #
	# Should eventually be a BIOM object (special class)#
	#########################################
	# Add header (not empty list by default, read file.)#
	# Add tree read/test if that is implemented.#
	return( BIOM(ab.mat, header=list(), taxonomy=taxdf, sampleData=samdata, tree=NULL) )#
#
}
read_biom(min_dense_file)
' Build and return an instance of the BIOM-class.#
#'#
#' This is for instantiating a BIOM object within R (\code{\link{BIOM-class}}),#
#' and assumes relevant data is already available in R. #
#' This is different than reading a BIOM file into R.#
#' If you are instead interested in importing a BIOM file into R,#
#' you should use the \code{\link{read_biom}} function. #
#' It is probably worth noting that \code{\link{read_biom}} uses this function#
#' to construct its \code{\link{BIOM-class}} instance after parsing the raw#
#' data from the BIOM file into R. #
#' This function is made available (exported) so that other users/developers#
#' can easily represent analogous data in this structure if needed.#
#'#
#' \code{BIOM()} is a constructor method. This is the main method#
#' suggested for constructing an experiment-level (\code{\link{BIOM-class}})#
#' object from its component data #
#' (component data classes: \code{\link{otuTable-class}}, \code{\link{sampleData-class}}, #
#'  \code{\link{taxonomyTable-class}}, \code{\link{phylo-class}}).#
#'#
#' @usage BIOM(abundance, header=list(), taxonomy=NULL, sampleData=NULL, tree=NULL)#
#'#
#' @param abundance (REQUIRED). A \code{\link{Matrix}}-class object of abundance values.#
#'  By convention, rows should represent taxa and columns different samples.#
#'#
#' @param header (OPTIONAL). A list or \code{NULL}. The header information describing#
#'  this BIOM file, it's format, and other meta-data.#
#'  Basically all the elements above \code{"rows"} in the BIOM format description.#
#'  \url{http://biom-format.org/documentation/format_versions/biom-1.0.html}.#
#'  Default is \code{NULL}.#
#'#
#' @param taxonomy (OPTIONAL). A (usually character-based) \code{link{matrix}} of#
#'  taxonomic ranks as columns and taxa as rows, or \code{NULL}.#
#'  Default is \code{NULL}.#
#'#
#' @param sampleData (OPTIONAL). A \code{link{data.frame}} representing Sample Data, or \code{NULL}.#
#'  Default is \code{NULL}#
#'#
#' @param tree (OPTIONAL). A \code{\link[ape]{phylo}}-class phylogenetic tree, or \code{NULL}.#
#'  Default is \code{NULL}#
#'#
#' @return An instance of the \code{\link{BIOM-class}}. #
#'#
#' @export#
#' @examples ##
#' # # Examples to go here.#
BIOM <- function(abundance, header=list(), taxonomy=NULL, sampleData=NULL, tree=NULL){#
	# # Some instantiation checks should go here...#
	# # Some can also be wrapped into validity methods.#
	biom <- new("BIOM",#
		header     = header,#
		abundance  = abundance,#
		taxonomy   = taxonomy,#
		sampleData = sampleData,#
		tree       = tree#
	)#
	return(biom)#
}#
#################################################################################
#################################################################################
#' Universal slot accessor for the \code{\link{BIOM-class}}.#
#'#
#' This function is used by slot-specific accessors. #
#'#
#' @usage access(physeq, slot, errorIfNULL=FALSE) #
#'#
#' @param biom (Required). \code{\link{BIOM-class}}.#
#'#
#' @param slot (Required). A character string indicating the slot (not data class)#
#'  of the component data type that is desired.#
#'#
#' @param errorIfNULL (Optional). Logical. Should the accessor stop with #
#'  an error if the slot is empty (\code{NULL})? Default \code{FALSE}. #
#'#
#' @return Returns the component object specified by the argument \code{slot}. #
#'  Returns NULL if slot does not exist. Returns \code{biom} as-is #
#'  if it is a component class that already matches the slot name.#
#'#
#' @keywords internal#
access <- function(biom, slot, errorIfNULL=FALSE){#
	slots <- getSlots("BIOM")#
	# Check that slot is actually a slot in this class.#
	 if(!slot %in% slotNames(biom) ){#
		out <- NULL#
	} else {#
		out <- eval(parse(text=paste("biom@", slot, sep=""))) #
	}#
	# Test if you should error upon the emptiness of the slot being accessed#
	if( errorIfNULL & is.null(out) ){#
		stop(slot, " slot is empty.")#
	}#
	return(out)#
}#
#################################################################################
#' Accessors for the \code{\link{BIOM-class}}. #
#' #
#' Convenience functions for accessing particular components of#
#' the \code{\link{BIOM-class}}. #
#'#
#' Some features of the BIOM-format can be essentially empty, and are #
#' represented as \code{NULL} in R once imported. #
#' By default, these accessors will throw an error if#
#' a \code{NULL} is encountered, under the assumption that you#
#' are using this accessor because you expect the component to be non-empty.#
#' Simply setting the second argument to \code{FALSE} relieves this and allows#
#' \code{NULL} to be returned silently.#
#'#
#' Internally these acessors wrap the not-exported \code{\link{access}} function.#
#' This helps ensure consistent behavior from accessors.#
#'#
#' @usage header(biom, errorIfNULL=TRUE)#
#' @usage abundance(biom, errorIfNULL=TRUE)#
#' @usage taxonomy(biom, errorIfNULL=TRUE)#
#' @usage sampleData(biom, errorIfNULL=TRUE)#
#' @usage tree(biom, errorIfNULL=TRUE)#
#'#
#' @param biom (Required). \code{\link{BIOM-class}}.#
#'#
#' @param errorIfNULL (Optional). Logical. Should the accessor stop with #
#'  an error if the slot is empty (\code{NULL})? Default \code{FALSE}. #
#'#
#' @name accessors#
#' @rdname accessor-functions#
#' @export#
#' @examples#
#' ## Examples here.#
header <- function(biom, errorIfNULL=TRUE){#
	access(biom, "header", errorIfNULL)#
}#
#################################################################################
#' @export#
#' @rdname accessor-functions#
abundance <- function(biom, errorIfNULL=TRUE){#
	access(biom, "abundance", errorIfNULL)#
}#
#################################################################################
#' @export#
#' @rdname accessor-functions#
taxonomy <- function(biom, errorIfNULL=TRUE){#
	access(biom, "taxonomy", errorIfNULL)#
}#
#################################################################################
#' @export#
#' @rdname accessor-functions#
sampleData <- function(biom, errorIfNULL=TRUE){#
	access(biom, "sampleData", errorIfNULL)#
}#
#################################################################################
#' @export#
#' @rdname accessor-functions#
tree <- function(biom, errorIfNULL=TRUE){#
	access(biom, "tree", errorIfNULL)#
}
read_biom(min_dense_file)
Test read_biom#
read_biom(min_dense_file)#
read_biom(min_sparse_file)#
read_biom(rich_dense_file)#
read_biom(rich_sparse_file)
' An S4 copy of the main phylogenetic tree class from the ape package.#
#'#
#' See the \code{\link[ape]{ape}} package for details about this type of#
#' representation of a phylogenetic tree. It is used throught ape.#
#'#
#' @seealso \code{\link[ape]{phylo}}, \code{\link{setOldClass}}#
#'#
#' @name phylo-class#
#' @rdname phylo-class#
#' @exportClass phylo#
setOldClass("phylo")#
#################################################################################
# Use setClassUnion to define the unholy NULL-data union as a virtual class.#
# This is a way of dealing with the expected scenarios in which one or more of#
# the component data classes is not available, in which case NULL will be used#
# instead.#
#################################################################################
#' @keywords internal#
setClassUnion("dataFrameOrNull", c("data.frame", "NULL"))#
#' @keywords internal#
setClassUnion("phyloOrNULL", c("phylo", "NULL"))#
#################################################################################
# Eventually, class definitions should go here. Most expected is a class#
# definition for the "BIOM" class that represents generally the BIOM format#
# structure within R.#
#################################################################################
#' A native R-representation of the BIOM format.#
#'#
#' For documentation of the format see \url{http://biom-format.org/}. #
#' #
#' slots:#
#' \describe{#
#'    \item{otuTable}{a single object of class otuTable.}#
#'    \item{samData}{ a single object of class sampleData.}#
#'    \item{taxTab}{ a single object of class taxonomyTable.}#
#'    \item{tre}{ a single object of class phylo, from the package ape}#
#' }#
#'#
#' @seealso#
#' The constructor, \code{\link{BIOM}}#
#' #
#' The accessors, \code{\link{header}}, \code{\link{abundance}},#
#'  \code{\link{taxonomy}}, \code{\link{sampleData}}, \code{\link{tree}}.#
#' #
#' @name BIOM-class#
#' @rdname BIOM-class#
#' @exportClass BIOM#
setClass("BIOM",#
	representation(#
	header     = "list",#
	abundance  = "Matrix",#
	taxonomy   = "dataFrameOrNull",#
	sampleData = "dataFrameOrNull",#
	tree       = "phyloOrNULL")#
)
Test read_biom#
read_biom(min_dense_file)#
read_biom(min_sparse_file)#
read_biom(rich_dense_file)#
read_biom(rich_sparse_file)
?identical
identical(x3, x4)
Test read_biom#
x1 <- read_biom(min_dense_file)#
x2 <- read_biom(min_sparse_file)#
x3 <- read_biom(rich_dense_file)#
x4 <- read_biom(rich_sparse_file)#
#
# Test that both mins are equal, and that both riches are equal#
identical(x1, x2)#
identical(x3, x4)
all.equal(x1, x2)
RBIOM biom import tests#
##
##
library("RJSONIO"); library("plyr"); library("Matrix")#
parallel <- FALSE#
#
if( getwd() != "~/github/biom-format/R-code/RBIOM/R"){#
	setwd("~/github/biom-format/R-code/RBIOM/R")#
}#
#
min_dense_file   <- "../../../examples/min_dense_otu_table.biom"#
min_sparse_file  <- "../../../examples/min_sparse_otu_table.biom"#
rich_dense_file  <- "../../../examples/rich_dense_otu_table.biom"#
rich_sparse_file <- "../../../examples/rich_sparse_otu_table.biom"#
#
# Test read_biom#
x1 <- read_biom(min_dense_file)#
x2 <- read_biom(min_sparse_file)#
x3 <- read_biom(rich_dense_file)#
x4 <- read_biom(rich_sparse_file)#
#
# Test that both mins are equal, and that both riches are equal#
if( !identical(x1, x2) ){#
	all.equal(x1, x2)#
}#
#
if( !identical(x3, x4) ){#
	all.equal(x3, x4)	#
}
x3
x4
all.equal(abundance(x1), abundance(x2))
all.equal(abundance(x1), abundance(x2))
?all.equal
abundance(x1) - abundance(x2)
if( !identical(x3, x4) ){#
	all.equal(x3, x4)#
	all.equal(abundance(x3), abundance(x4))#
	abundance(x3) - abundance(x4)	#
}
identical(abundance(x1), abundance(x3))
identical(abundance(x2), abundance(x4))
RBIOM biom import tests#
##
##
library("RJSONIO"); library("plyr"); library("Matrix")#
parallel <- FALSE#
#
if( getwd() != "~/github/biom-format/R-code/RBIOM/R"){#
	setwd("~/github/biom-format/R-code/RBIOM/R")#
}#
#
min_dense_file   <- "../../../examples/min_dense_otu_table.biom"#
min_sparse_file  <- "../../../examples/min_sparse_otu_table.biom"#
rich_dense_file  <- "../../../examples/rich_dense_otu_table.biom"#
rich_sparse_file <- "../../../examples/rich_sparse_otu_table.biom"#
#
# Test read_biom#
x1 <- read_biom(min_dense_file)#
x2 <- read_biom(min_sparse_file)#
x3 <- read_biom(rich_dense_file)#
x4 <- read_biom(rich_sparse_file)#
#
# Test that both mins are equal, and that both riches are equal#
if( !identical(x1, x2) ){#
	all.equal(x1, x2)#
	all.equal(abundance(x1), abundance(x2))#
	abundance(x1) - abundance(x2)#
}#
#
if( !identical(x3, x4) ){#
	all.equal(x3, x4)#
	all.equal(abundance(x3), abundance(x4))#
	abundance(x3) - abundance(x4)	#
}#
#
identical(abundance(x1), abundance(x3))#
identical(abundance(x2), abundance(x4))
